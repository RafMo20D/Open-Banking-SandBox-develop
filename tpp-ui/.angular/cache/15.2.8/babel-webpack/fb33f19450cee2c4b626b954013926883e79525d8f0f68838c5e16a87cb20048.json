{"ast":null,"code":"import { Pipe, Injectable, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport * as ɵngcc0 from '@angular/core';\nlet FilterPipe = /*#__PURE__*/(() => {\n  class FilterPipe {\n    /**\n     * @param {?} value\n     * @param {?} key\n     * @return {?}\n     */\n    static isFoundOnWalking(value, key) {\n      let /** @type {?} */walker = value;\n      let /** @type {?} */found = false;\n      do {\n        if (walker.hasOwnProperty(key) || Object.getOwnPropertyDescriptor(walker, key)) {\n          found = true;\n          break;\n        }\n      } while (walker = Object.getPrototypeOf(walker));\n      return found;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    static isNumber(value) {\n      return !isNaN(parseInt(value, 10)) && isFinite(value);\n    }\n    /**\n     * Checks function's value if type is function otherwise same value\n     * @param {?} value\n     * @return {?}\n     */\n    static getValue(value) {\n      return typeof value === 'function' ? value() : value;\n    }\n    /**\n     * @param {?} filter\n     * @return {?}\n     */\n    filterByString(filter) {\n      if (filter) {\n        filter = filter.toLowerCase();\n      }\n      return value => !filter || (value ? ('' + value).toLowerCase().indexOf(filter) !== -1 : false);\n    }\n    /**\n     * @param {?} filter\n     * @return {?}\n     */\n    filterByBoolean(filter) {\n      return value => Boolean(value) === filter;\n    }\n    /**\n     * @param {?} filter\n     * @return {?}\n     */\n    filterByObject(filter) {\n      return value => {\n        for (const /** @type {?} */key in filter) {\n          if (key === '$or') {\n            if (!this.filterByOr(filter.$or)(FilterPipe.getValue(value))) {\n              return false;\n            }\n            continue;\n          }\n          if (!value || !FilterPipe.isFoundOnWalking(value, key)) {\n            return false;\n          }\n          if (!this.isMatching(filter[key], FilterPipe.getValue(value[key]))) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    /**\n     * @param {?} filter\n     * @param {?} val\n     * @return {?}\n     */\n    isMatching(filter, val) {\n      switch (typeof filter) {\n        case 'boolean':\n          return this.filterByBoolean(filter)(val);\n        case 'string':\n          return this.filterByString(filter)(val);\n        case 'object':\n          return this.filterByObject(filter)(val);\n      }\n      return this.filterDefault(filter)(val);\n    }\n    /**\n     * Filter value by $or\n     * @param {?} filter\n     * @return {?}\n     */\n    filterByOr(filter) {\n      return value => {\n        const /** @type {?} */length = filter.length;\n        const /** @type {?} */arrayComparison = i => value.indexOf(filter[i]) !== -1;\n        const /** @type {?} */otherComparison = i => this.isMatching(filter[i], value);\n        const /** @type {?} */comparison = Array.isArray(value) ? arrayComparison : otherComparison;\n        for (let /** @type {?} */i = 0; i < length; i++) {\n          if (comparison(i)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    /**\n     * Default filterDefault function\n     * @param {?} filter\n     * @return {?}\n     */\n    filterDefault(filter) {\n      return value => filter === undefined || filter == value;\n    }\n    /**\n     * @param {?} array\n     * @param {?} filter\n     * @return {?}\n     */\n    transform(array, filter) {\n      if (!array) {\n        return array;\n      }\n      switch (typeof filter) {\n        case 'boolean':\n          return array.filter(this.filterByBoolean(filter));\n        case 'string':\n          if (FilterPipe.isNumber(filter)) {\n            return array.filter(this.filterDefault(filter));\n          }\n          return array.filter(this.filterByString(filter));\n        case 'object':\n          return array.filter(this.filterByObject(filter));\n        case 'function':\n          return array.filter(filter);\n      }\n      return array.filter(this.filterDefault(filter));\n    }\n  }\n  FilterPipe.ɵfac = function FilterPipe_Factory(t) {\n    return new (t || FilterPipe)();\n  };\n  FilterPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"filterBy\",\n    type: FilterPipe,\n    pure: false\n  });\n  FilterPipe.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: FilterPipe,\n    factory: FilterPipe.ɵfac\n  });\n  /** @nocollapse */\n  return FilterPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nlet FilterPipeModule = /*#__PURE__*/(() => {\n  class FilterPipeModule {}\n  FilterPipeModule.ɵfac = function FilterPipeModule_Factory(t) {\n    return new (t || FilterPipeModule)();\n  };\n  FilterPipeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: FilterPipeModule\n  });\n  FilterPipeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [FilterPipe]\n  });\n  /** @nocollapse */\n  return FilterPipeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FilterPipeModule, {\n    declarations: [FilterPipe],\n    exports: [FilterPipe]\n  });\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FilterPipeModule, FilterPipe };\n\n//# sourceMappingURL=ngx-filter-pipe.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}