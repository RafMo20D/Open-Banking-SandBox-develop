{"ast":null,"code":"/*\r\n * Copyright 2018-2023 adorsys GmbH & Co KG\r\n *\r\n * This program is free software: you can redistribute it and/or modify it\r\n * under the terms of the GNU Affero General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or (at\r\n * your option) any later version. This program is distributed in the hope that\r\n * it will be useful, but WITHOUT ANY WARRANTY; without even the implied\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n * See the GNU Affero General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Affero General Public License\r\n * along with this program. If not, see https://www.gnu.org/licenses/.\r\n *\r\n * This project is also available under a separate commercial license. You can\r\n * contact us at psd2@adorsys.com.\r\n */\nimport { DOCUMENT } from '@angular/common';\nimport { HttpClient } from '@angular/common/http';\nimport { InjectionToken, Optional, SecurityContext, SkipSelf } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { of as observableOf, throwError as observableThrow } from 'rxjs';\nimport { finalize, map, share, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"@angular/platform-browser\";\n/**\r\n * Returns an exception to be thrown in the case when attempting to\r\n * load an icon with a name that cannot be found.\r\n * @docs-private\r\n */\nexport function getIconNameNotFoundError(iconName) {\n  return Error(`Unable to find icon with the name \"${iconName}\"`);\n}\n/**\r\n * Returns an exception to be thrown when the consumer attempts to use\r\n * `<app-icon>` without including @angular/http.\r\n * @docs-private\r\n */\nexport function getIconNoHttpProviderError() {\n  return Error('Could not find HttpClient provider. ' + 'Please include the HttpClientModule from @angular/common/http in your ' + 'app imports.');\n}\n/**\r\n * Returns an exception to be thrown when a URL couldn't be sanitized.\r\n * @param url URL that was attempted to be sanitized.\r\n * @docs-private\r\n */\nexport function getIconFailedToSanitizeUrlError(url) {\n  return Error(`The URL provided to KbnIconRegistry was not trusted as a resource URL ` + `via Angular's DomSanitizer. Attempted URL was \"${url}\".`);\n}\n/**\r\n * Configuration for an icon, including the URL and possibly the cached SVG element.\r\n * @docs-private\r\n */\nclass SvgIconConfig {\n  constructor(data) {\n    // Note that we can't use `instanceof SVGElement` here,\n    // because it'll break during server-side rendering.\n    if (data.nodeName) {\n      this.svgElement = data;\n    } else {\n      this.url = data;\n    }\n  }\n}\n/**\r\n * Service to register and display icons used by the `<app-icon>` component.\r\n * - Registers icon URLs by namespace and name.\r\n * - Registers icon set URLs by namespace.\r\n * - Loads icons from URLs and extracts individual icons from icon sets.\r\n */\nexport let IconRegistry = /*#__PURE__*/(() => {\n  class IconRegistry {\n    constructor(_httpClient, _sanitizer, document) {\n      this._httpClient = _httpClient;\n      this._sanitizer = _sanitizer;\n      /**\r\n       * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\r\n       */\n      this._svgIconConfigs = new Map();\n      /** Cache for icons loaded by direct URLs. */\n      this._cachedIconsByUrl = new Map();\n      /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n      this._inProgressUrlFetches = new Map();\n      this._document = document;\n    }\n    /**\r\n     * Registers an icon by URL in the default namespace.\r\n     * @param iconName Name under which the icon should be registered.\r\n     * @param url\r\n     */\n    addSvgIcon(iconName, url) {\n      return this.addSvgIconInNamespace('', iconName, url);\n    }\n    /**\r\n     * Registers an icon by URL in the specified namespace.\r\n     * @param namespace Namespace in which the icon should be registered.\r\n     * @param iconName Name under which the icon should be registered.\r\n     * @param url\r\n     */\n    addSvgIconInNamespace(namespace, iconName, url) {\n      return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url));\n    }\n    /**\r\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.\r\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\r\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\r\n     * it will not contain any modifications made to elements previously returned).\r\n     *\r\n     * @param safeUrl URL from which to fetch the SVG icon.\r\n     */\n    getSvgIconFromUrl(safeUrl) {\n      const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n      if (!url) {\n        throw getIconFailedToSanitizeUrlError(safeUrl);\n      }\n      const cachedIcon = this._cachedIconsByUrl.get(url);\n      if (cachedIcon) {\n        return observableOf(cloneSvg(cachedIcon));\n      }\n      return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl)).pipe(\n      // tslint:disable-next-line:no-non-null-assertion\n      tap(svg => this._cachedIconsByUrl.set(url, svg)), map(svg => cloneSvg(svg)));\n    }\n    /**\r\n     * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name\r\n     * and namespace. The icon must have been previously registered with addIcon;\r\n     * if not, the Observable will throw an error.\r\n     *\r\n     * @param name Name of the icon to be retrieved.\r\n     * @param namespace Namespace in which to look for the icon.\r\n     */\n    getNamedSvgIcon(name, namespace = '') {\n      // Return (copy of) cached icon if possible.\n      const key = iconKey(namespace, name);\n      const config = this._svgIconConfigs.get(key);\n      if (config) {\n        return this._getSvgFromConfig(config);\n      }\n      return observableThrow(getIconNameNotFoundError(key));\n    }\n    ngOnDestroy() {\n      this._svgIconConfigs.clear();\n      this._cachedIconsByUrl.clear();\n    }\n    /**\r\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\r\n     */\n    _getSvgFromConfig(config) {\n      if (config.svgElement) {\n        // We already have the SVG element for this icon, return a copy.\n        return observableOf(cloneSvg(config.svgElement));\n      } else {\n        // Fetch the icon from the config's URL, cache it, and return a copy.\n        return this._loadSvgIconFromConfig(config).pipe(tap(svg => config.svgElement = svg), map(svg => cloneSvg(svg)));\n      }\n    }\n    /**\r\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\r\n     * from it.\r\n     */\n    _loadSvgIconFromConfig(config) {\n      return this._fetchUrl(config.url).pipe(map(svgText => this._createSvgElementForSingleIcon(svgText)));\n    }\n    /**\r\n     * Creates a DOM element from the given SVG string, and adds default attributes.\r\n     */\n    _createSvgElementForSingleIcon(responseText) {\n      const svg = this._svgElementFromString(responseText);\n      this._setSvgAttributes(svg);\n      return svg;\n    }\n    /**\r\n     * Creates a DOM element from the given SVG string.\r\n     */\n    _svgElementFromString(str) {\n      const div = this._document.createElement('DIV');\n      div.innerHTML = str;\n      const svg = div.querySelector('svg');\n      if (!svg) {\n        throw Error('<svg> tag not found');\n      }\n      return svg;\n    }\n    /**\r\n     * Sets the default attributes for an SVG element to be used as an icon.\r\n     */\n    _setSvgAttributes(svg) {\n      svg.setAttribute('fit', '');\n      svg.setAttribute('height', '100%');\n      svg.setAttribute('width', '100%');\n      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n      svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n      return svg;\n    }\n    /**\r\n     * Returns an Observable which produces the string contents of the given URL. Results may be\r\n     * cached, so future calls with the same URL may not cause another HTTP request.\r\n     */\n    _fetchUrl(safeUrl) {\n      if (!this._httpClient) {\n        throw getIconNoHttpProviderError();\n      }\n      if (safeUrl == null) {\n        throw Error(`Cannot fetch icon from URL \"${safeUrl}\".`);\n      }\n      const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);\n      if (!url) {\n        throw getIconFailedToSanitizeUrlError(safeUrl);\n      }\n      // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n      // already a request in progress for that URL. It's necessary to call share() on the\n      // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n      const inProgressFetch = this._inProgressUrlFetches.get(url);\n      if (inProgressFetch) {\n        return inProgressFetch;\n      }\n      // TODO(jelbourn): for some reason, the `finalize` operator \"loses\" the generic type on the\n      // Observable. Figure out why and fix it.\n      const req = this._httpClient.get(url, {\n        responseType: 'text'\n      }).pipe(finalize(() => this._inProgressUrlFetches.delete(url)), share());\n      this._inProgressUrlFetches.set(url, req);\n      return req;\n    }\n    /**\r\n     * Registers an icon config by name in the specified namespace.\r\n     * @param namespace Namespace in which to register the icon config.\r\n     * @param iconName Name under which to register the config.\r\n     * @param config Config to be registered.\r\n     */\n    _addSvgIconConfig(namespace, iconName, config) {\n      this._svgIconConfigs.set(iconKey(namespace, iconName), config);\n      return this;\n    }\n    static #_ = this.ɵfac = function IconRegistry_Factory(t) {\n      return new (t || IconRegistry)(i0.ɵɵinject(i1.HttpClient, 8), i0.ɵɵinject(i2.DomSanitizer), i0.ɵɵinject(DOCUMENT, 8));\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: IconRegistry,\n      factory: IconRegistry.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return IconRegistry;\n})();\n/** @docs-private */\nexport function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, document) {\n  return parentRegistry || new IconRegistry(httpClient, sanitizer, document);\n}\n/** @docs-private */\nexport const ICON_REGISTRY_PROVIDER = {\n  // If there is already an KbnIconRegistry available, use that. Otherwise, provide a new one.\n  provide: IconRegistry,\n  deps: [[new Optional(), new SkipSelf(), IconRegistry], [new Optional(), HttpClient], DomSanitizer, [new Optional(), DOCUMENT]],\n  useFactory: ICON_REGISTRY_PROVIDER_FACTORY\n};\n/** Clones an SVGElement while preserving type information. */\nfunction cloneSvg(svg) {\n  return svg.cloneNode(true);\n}\n/** Returns the cache key to use for an icon namespace and name. */\nfunction iconKey(namespace, name) {\n  return namespace + ':' + name;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}