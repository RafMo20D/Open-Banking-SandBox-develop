{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport { getActionTypeFromInstance, Store, NGXS_PLUGINS } from '@ngxs/store';\nimport { tap, catchError } from 'rxjs/operators';\nconst repeat = (str, times) => new Array(times + 1).join(str);\nconst pad = (num, maxLength) => repeat('0', maxLength - num.toString().length) + num;\nfunction formatTime(time) {\n  return pad(time.getHours(), 2) + `:` + pad(time.getMinutes(), 2) + `:` + pad(time.getSeconds(), 2) + `.` + pad(time.getMilliseconds(), 3);\n}\nclass ActionLogger {\n  constructor(action, store, logWriter) {\n    this.action = action;\n    this.store = store;\n    this.logWriter = logWriter;\n  }\n  dispatched(state) {\n    const actionName = getActionTypeFromInstance(this.action);\n    const formattedTime = formatTime(new Date());\n    const message = `action ${actionName} @ ${formattedTime}`;\n    this.logWriter.startGroup(message);\n    // print payload only if at least one property is supplied\n    if (this._hasPayload(this.action)) {\n      this.logWriter.logGrey('payload', Object.assign({}, this.action));\n    }\n    this.logWriter.logGrey('prev state', state);\n  }\n  completed(nextState) {\n    this.logWriter.logGreen('next state', nextState);\n    this.logWriter.endGroup();\n  }\n  errored(error) {\n    this.logWriter.logRedish('next state after error', this.store.snapshot());\n    this.logWriter.logRedish('error', error);\n    this.logWriter.endGroup();\n  }\n  _hasPayload(event) {\n    const nonEmptyProperties = this._getNonEmptyProperties(event);\n    return nonEmptyProperties.length > 0;\n  }\n  _getNonEmptyProperties(event) {\n    const keys = Object.keys(event);\n    const values = keys.map(key => event[key]);\n    return values.filter(value => value !== undefined);\n  }\n}\nclass LogWriter {\n  constructor(options) {\n    this.options = options;\n    this.options = this.options || {};\n    this.logger = options.logger || console;\n  }\n  startGroup(message) {\n    const startGroupFn = this.options.collapsed ? this.logger.groupCollapsed : this.logger.group;\n    try {\n      startGroupFn.call(this.logger, message);\n    } catch (e) {\n      console.log(message);\n    }\n  }\n  endGroup() {\n    try {\n      this.logger.groupEnd();\n    } catch (e) {\n      this.logger.log('—— log end ——');\n    }\n  }\n  logGrey(title, payload) {\n    const greyStyle = 'color: #9E9E9E; font-weight: bold';\n    this.log(title, greyStyle, payload);\n  }\n  logGreen(title, payload) {\n    const greenStyle = 'color: #4CAF50; font-weight: bold';\n    this.log(title, greenStyle, payload);\n  }\n  logRedish(title, payload) {\n    const redishStyle = 'color: #FD8182; font-weight: bold';\n    this.log(title, redishStyle, payload);\n  }\n  log(title, color, payload) {\n    if (this.isIE()) {\n      this.logger.log(title, payload);\n    } else {\n      this.logger.log('%c ' + title, color, payload);\n    }\n  }\n  isIE() {\n    const ua = typeof window !== 'undefined' && window.navigator.userAgent ? window.navigator.userAgent : '';\n    let msIE = false;\n    const oldIE = ua.indexOf('MSIE ');\n    const newIE = ua.indexOf('Trident/');\n    if (oldIE > -1 || newIE > -1) {\n      msIE = true;\n    }\n    return msIE;\n  }\n}\nconst NGXS_LOGGER_PLUGIN_OPTIONS = new InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');\nlet NgxsLoggerPlugin = /*#__PURE__*/(() => {\n  class NgxsLoggerPlugin {\n    constructor(_options, _injector) {\n      this._options = _options;\n      this._injector = _injector;\n    }\n    handle(state, event, next) {\n      if (this._options.disabled || !this._options.filter(event, state)) {\n        return next(state, event);\n      }\n      this._logWriter = this._logWriter || new LogWriter(this._options);\n      // Retrieve lazily to avoid cyclic dependency exception\n      this._store = this._store || this._injector.get(Store);\n      const actionLogger = new ActionLogger(event, this._store, this._logWriter);\n      actionLogger.dispatched(state);\n      return next(state, event).pipe(tap(nextState => {\n        actionLogger.completed(nextState);\n      }), catchError(error => {\n        actionLogger.errored(error);\n        throw error;\n      }));\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NgxsLoggerPlugin.ɵfac = function NgxsLoggerPlugin_Factory(t) {\n    return new (t || NgxsLoggerPlugin)(i0.ɵɵinject(NGXS_LOGGER_PLUGIN_OPTIONS), i0.ɵɵinject(i0.Injector));\n  };\n  NgxsLoggerPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsLoggerPlugin,\n    factory: NgxsLoggerPlugin.ɵfac\n  });\n  return NgxsLoggerPlugin;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst USER_OPTIONS = new InjectionToken('LOGGER_USER_OPTIONS');\nfunction loggerOptionsFactory(options) {\n  const defaultLoggerOptions = {\n    logger: console,\n    collapsed: false,\n    disabled: false,\n    filter: () => true\n  };\n  return Object.assign(Object.assign({}, defaultLoggerOptions), options);\n}\nlet NgxsLoggerPluginModule = /*#__PURE__*/(() => {\n  class NgxsLoggerPluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsLoggerPluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsLoggerPlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_LOGGER_PLUGIN_OPTIONS,\n          useFactory: loggerOptionsFactory,\n          deps: [USER_OPTIONS]\n        }]\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsLoggerPluginModule.ɵfac = function NgxsLoggerPluginModule_Factory(t) {\n    return new (t || NgxsLoggerPluginModule)();\n  };\n  NgxsLoggerPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsLoggerPluginModule\n  });\n  NgxsLoggerPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsLoggerPluginModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The public api for consumers of @ngxs/logger-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXS_LOGGER_PLUGIN_OPTIONS, NgxsLoggerPlugin, NgxsLoggerPluginModule };\n//# sourceMappingURL=ngxs-logger-plugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}